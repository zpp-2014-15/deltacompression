% Niniejszy plik stanowi przyk³ad formatowania pracy magisterskiej na Wydziale MIM UW.  Szkielet u¿ytych poleceñ mo¿na wykorzystywaæ do woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrze¿one.
%
% Copyright (c) 2001 by Marcin Woliñski <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Kar³owicz, 05.05.2006
% dodaj opcjê [licencjacka] dla pracy licencjackiej
\documentclass[licencjacka]{styles}

\usepackage{polski}
\usepackage{url}
\usepackage{graphicx}
\usepackage{pgffor}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{indentfirst}
\usepackage{longtable}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{enumitem}
\captionsetup[sub]{labelsep=space}
\urlstyle{same}

% it's for non-breaking hlines in longtable
\makeatletter
\newcommand\nobreakhline{%
\multispan\LT@cols
\unskip\leaders\hrule\@height\arrayrulewidth\hfill\\*}
\newcommand\nobreakcline[1]{\@nobreakcline#1\@nil}%
\def\@nobreakcline#1-#2\@nil{%
  \omit
  \@multicnt#1%
  \advance\@multispan\m@ne
  \ifnum\@multicnt=\@ne\@firstofone{&\omit}\fi
  \@multicnt#2%
  \advance\@multicnt-#1%
  \advance\@multispan\@ne
  \leaders\hrule\@height\arrayrulewidth\hfill\\*
  \noalign{\vskip-\arrayrulewidth}}
\makeatother

%Jesli uzywasz kodowania polskich znakow ISO-8859-2 nastepna linia powinna byc odkomentowana
%\usepackage[latin2]{inputenc}
%Jesli uzywasz kodowania polskich znakow CP-1250 to ta linia powinna byc  odkomentowana
\usepackage[cp1250]{inputenc}

% Uwaga: ka¿dy z nas czworga ma oddzielny egzemplarz i wpisuje swoje dane
\author{Krzysztof Kiewicz \\ Pawe³ Kura \\ Dawid £azarczyk \\ Marcel Ziêba}

\nralbumu{337182, 337581, 337614, 337768}

\title{Optymalizacja ruchu sieciowego w symulowanym systemie rozproszonych kopii zapasowych}

\tytulang{Optimization of network traffic in distributed backup systems}

\kierunek{Informatyka}

% Praca wykonana pod kierunkiem:
% (podaæ tytu³/stopieñ imiê i nazwisko opiekuna
% Instytut
% ew. Wydzia³ ew. Uczelnia (je¿eli nie MIM UW))
\opiekun{dra Roberta D¹browskiego\\
  Instytut Informatyki\\
  }

% miesi¹c i~rok:
\date{Czerwiec 2015}

%Podaæ dziedzinê wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
11.3 Informatyka\\ 
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
	10002951 Information systems\\
	10002951.10003152.10003517.10003519 Distributed storage\\
  10002951.10002952.10002971.10003451.10002975 Data compression
  }
% S³owa kluczowe:
\keywords{delta kodowanie, indeks podobieñstwa, optymalizacja ruchu sieciowego, rozproszony system kopii zapasowych}

% Tu jest dobre miejsce na Twoje w³asne makra i~œrodowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
W pracy przedstawiono opis symulatora systemu rozproszonych kopii zapasowych.
Symulator naœladuje pracê systemu HYDRAstor oraz pozwala na zbadanie wp³ywu wdro¿enia algorytmów delta kodowania na wydajnoœæ systemu.
Przeprowadzono symulacje na kilku zestawach danych, a ich wyniki wraz z omówieniem zosta³y zamieszczone w pracy.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables


\chapter*{Wstêp}
\addcontentsline{toc}{chapter}{Wstêp}
Dyski komputerów na ca³ym œwiecie przechowuj¹ tysi¹ce terabajtów danych. 
Czêœæ z tych danych jest bardzo wa¿na i wymaga kopii zapasowych.
W obecnych systemach kopii zapasowych standardowym rozwi¹zaniem jest trzykrotna replikacja danych.
Przewa¿nie jest ona wykonywana w obrêbie jednego centrum danych.
Mo¿na jednak zapewniæ wiêksz¹ odpornoœæ na b³êdy wykonuj¹c replikê w innym centrum danych.
Du¿ym problemem tego rozwi¹zania jest wydajnoœæ ³¹cza internetowego.
Zwyk³e przesy³anie danych mo¿e zaj¹æ du¿o czasu.
Istniej¹ jednak algorytmy, które pozwalaj¹ na znaczne zmniejszenie rozmiaru danych potrzebnych do przes³ania.
Jednym z takich rozwi¹zañ s¹ algorytmy delta kodowania.
HYDRAstor to system firmy 9LivesData, który pozwala na szybkie i bezpieczne tworzenie kopii zapasowych.
Jest on pozbawiony delta kodowania.
Niestety zaimplementowanie nowego algorytmu w systemie produkcyjnym wymaga du¿ego nak³adu pracy.
Trudno jest równie¿ przewidzieæ, jak efektywnie bêdzie on dzia³a³.
Dlatego na zlecenie firmy 9LivesData stworzyliœmy symulator systemu HYDRAstor.
Dziêki niemu mo¿na testowaæ algorytmy delta kodowania przed ich czasoch³onn¹ implementacj¹ w prawdziwym systemie.
W niniejszej pracy przedstawiamy symulator oraz wyniki symulacji uzyskane przy jego pomocy.

% pamiêtamy [*] W wielu wspó³czesnych systemach kopii zapasowych w¹skim gard³em procesu tworzenia repliki jest przesy³anie danych ³¹czem internetowym.

\chapter{System HYDRAstor}
HYDRAstor to nowoczesny, rozproszony, skalowalny system kopii zapasowych.
Jest jednym z najwiêkszych i najszybszych takich systemów na œwiecie u¿ywanym przez klientów w Japonii i Stanach Zjednoczonych (\cite{HYDRAstor}).
Dostarcza klientom funkcjonalnoœci takie jak: samozarz¹dzanie, samoregulacja, deduplikacja oraz ci¹g³e, niezak³ócaj¹ce pracy, aktualizacje.
Ponadto system charakteryzuje siê du¿¹ odpornoœci¹ na b³êdy.

System HYDRAstor jest niezwykle z³o¿ony i skomplikowany, dlatego zostanie zaprezentowany w du¿ym uproszczeniu.
Rysunek \ref{fig:hydra_scheme} przedstawia schemat systemu.
Do Chunkera dostarczane s¹ dane i metadane systemu plików w postaci strumienia bajtów.
Chunker dzieli strumieñ na bloki zmiennej d³ugoœci.
Bloki wraz z metadanymi s¹ dostarczane do systemu HYDRAstor poprzez po³¹czenie lokalne.
System HYDRAstor przechowuje jedynie unikalne bloki.
Proces eliminowania powtarzaj¹cych siê bloków nosi nazwê deduplikacji.
W celu przes³ania kopii zapasowej na zdalny serwer nowe dane s¹ kompresowane i przesy³ane przez Internet (replikacja).

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/HYDRAstor.png}
    \caption{Schemat systemu HYDRAstor}
    \label{fig:hydra_scheme}
\end{figure}

Bêdziemy teraz rozwa¿aæ wp³yw bloków zmiennej d³ugoœci i deduplikacji na dzia³anie systemu.
Na koniec powiemy, w jaki sposób mo¿na niezale¿nie od istniej¹cych mechanizmów zwiêkszyæ efektywnoœæ replikacji.

\section{Deduplikacja}
Dla ka¿dego bloku tworzony jest identyfikator za pomoc¹ funkcji skrótu SHA-2.
Ca³y system jest wyposa¿ony w rozproszon¹ tablicê mieszaj¹c¹, dziêki czemu mo¿na szybko sprawdziæ, czy dany blok jest ju¿ zapisany w systemie.
Pozwala to na eliminacjê duplikatów i przechowywanie tylko unikalnych bloków.
Pomaga to równie¿ w replikacji, poniewa¿ liczba bloków oraz rozmiar danych wymaganych do przes³ania s¹ znacznie mniejsze.
Ma to du¿e znaczenie przede wszystkim wtedy, gdy kopie s¹ wykonywane czêsto i dane w wiêkszoœci siê nie zmieniaj¹.

Rysunki \ref{fig:hydra1} - \ref{fig:hydra4} przedstawiaj¹ tê sytuacjê.

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/visualization/1.png}
        \captionof{figure}{System A chce przes³aæ do systemu B dane.}
        \label{fig:hydra1}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/visualization/2.png}
        \captionof{figure}{System A dzieli dane na bloki i dla ka¿dego z bloków liczy wartoœæ funkcji skrótu. W tym momencie s¹ wykrywane duplikaty - blok H1 wystêpuje dwa razy.}
        \label{fig:hydra2}
    \end{minipage}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth,keepaspectratio]{img/visualization/3.png}
        \captionof{figure}{System A przesy³a do systemu B zawartoœci wszystkich nowych bloków. W tym przypadku s¹ to bloki H1, H2, H3.}
        \label{fig:hydra3}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth,keepaspectratio]{img/visualization/4.png}
        \captionof{figure}{System B posiada teraz takie same bloki co system A.}
        \label{fig:hydra4}
    \end{minipage}
\end{figure}

\section{Bloki zmiennej d³ugoœci}
U¿ycie bloków zmiennej d³ugoœci pozwala w znacznym stopniu zmniejszyæ rozmiar danych, które zostan¹ przes³ane podczas replikacji.
Za³ó¿my chwilowo, ¿e stosujemy bloki sta³ej wielkoœci i mamy na serwerze strumieñ danych o bardzo du¿ym rozmiarze.
Nastêpnie w œrodku tego strumienia zostaje dodany jeden znak.
Sprawia to, ¿e po³owa strumienia zostaje podzielona na zupe³nie inne bloki, mimo ¿e dane siê praktycznie nie zmieni³y.

Zastosowanie bloków zmiennej d³ugoœci pozwala unikn¹æ tego problemu.
Oczywiœcie wybór granic dla bloków nie mo¿e byæ przypadkowy.
Chunker wybiera miejsce podzia³u, bior¹c pod uwagê lokalne w³aœciwoœci strumienia danych.
Dziêki temu wiêkszoœæ granic nie zmieni siê przy niewielkich modyfikacjach danych.
We wczeœniejszym przyk³adzie, w którym dodano jeden znak, Chunker wyznaczy³by granice tak, ¿e kilka bloków po nowym znaku by³oby innych, ale reszta nie zmieni³aby siê.
Przyk³ad prezentuj¹ rysunki \ref{fig:hydra5} - \ref{fig:hydra8}.

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth,keepaspectratio]{img/visualization/5.png}
        \captionof{figure}{System A chce przes³aæ do systemu B now¹ wersjê danych.}
        \label{fig:hydra5}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth,keepaspectratio]{img/visualization/6.png}
        \captionof{figure}{Dane uleg³y niewielkiej zmianie(kolor zielony). System A dzieli dane na bloki zmiennej d³ugoœci. Pojawi³y siê tylko dwa nowe bloki - H4, H5.}
        \label{fig:hydra6}
    \end{minipage}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth,keepaspectratio]{img/visualization/7.png}
        \captionof{figure}{System A przesy³a do systemu B zawartoœci wszystkich nowych bloków. W tym przypadku s¹ to bloki H4, H5.}
        \label{fig:hydra7}
    \end{minipage}
    \hspace{\fill}
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth,keepaspectratio]{img/visualization/8.png}
        \captionof{figure}{System B odbiera nowe dane i posiada teraz takie same bloki co system A.}
        \label{fig:hydra8}
    \end{minipage}
\end{figure}



\section{Mo¿liwe optymalizacje}
Deduplikacja oraz bloki zmiennej d³ugoœci znacznie przyspieszaj¹ replikacjê w systemie HYDRAstor.
W pewnych sytuacjach mo¿na jednak przesy³aæ zdecydowanie mniej danych.
Dla wielu nowych bloków mo¿emy znaleŸæ w systemie bloki bardzo podobne (np. ró¿ni¹ce siê tylko kilkoma znakami).
W powy¿szym przyk³adzie (rysunek \ref{fig:hydra6}) zmiana danych by³a bardzo ma³a.
Bloki H4 i H5 niewiele siê ró¿ni¹ od bloku H2.
Dla ka¿dego z nowych bloków mo¿na przes³aæ jedynie identyfikator bloku bazowego (w tym przypadku jest to identyfikator H2) oraz ró¿nicê.
W wiêkszoœci przypadków mia³oby to znacznie mniejszy rozmiar ni¿ ca³y nowy blok.
Algorytmy delta kodowania zajmuj¹ siê w³aœnie tym zadaniem.
Opiszemy je szerzej w nastêpnym rozdziale.

\chapter{Delta kodowanie}
Delta kodowanie to sposób transmisji danych w formie ró¿nic (ang. \textit{delta}) pomiêdzy blokami danych.
Gdy bloki s¹ do siebie podobne, delta kodowanie potrafi znacznie zmniejszyæ rozmiar przesy³anych danych.
Na wielkoœæ ró¿nic wp³yw ma to, które dane s¹ ze sob¹ porównywane oraz jaki algorytm liczenia ró¿nic jest u¿ywany.
Delta kodowanie mo¿na wiêc sprowadziæ do dwóch zasadniczych problemów: znajdowania podobnych bloków i liczenia ró¿nic miêdzy nimi.
\section{Liczenie ró¿nic}
Chcemy efektywnie rozwi¹zywaæ nastêpuj¹cy problem.
Mamy dane dwa bloki danych.
Ustalmy jeden z nich jako blok bazowy.
Naszym celem jest obliczyæ ró¿nicê drugiego bloku w stosunku do bloku bazowego tak, aby maj¹c jedynie blok bazowy i tê ró¿nicê, odtworzyæ drugi blok.
D¹¿ymy do minimalizacji rozmiaru ró¿nicy.

Popularnym algorytmem liczenia ró¿nic jest Diff z systemów Unix.
Jednak nie sprawdza siê on w przypadku delta kodowania.
Algorytm Diff porównuje bloki na poziomie linii, co nie dzia³a³oby zbyt dobrze dla danych innych ni¿ tekstowe.

Interesuj¹ nas wiêc przede wszystkim algorytmy przeznaczone do liczenia ró¿nic miêdzy danymi binarnymi.
Jednym z nich jest xdelta3.
W du¿ym uproszczeniu jego dzia³anie polega na sekwencyjnym odtwarzaniu bloku za pomoc¹ nastêpuj¹cych operacji:
\begin{itemize}
\item wstawienie danego ci¹gu bajtów
\item skopiowanie ci¹gu bajtów z odtworzonego ju¿ fragmentu
\item skopiowanie ci¹gu bajtów z fragmentu bloku bazowego
\end{itemize}
Wiêcej na temat xdelta3 mo¿na przeczytaæ na stronie autora \cite{xDelta}.

\section{Znajdowanie podobnych bloków}
Szukamy rozwi¹zania nastêpuj¹cego problemu.
Mamy dane: zbiór starych bloków i jeden nowy blok.
Chcemy znaleŸæ stary blok, dla którego ró¿nica z nowym blokiem jest mo¿liwie ma³a.
Zaprezentujemy dwa rozwi¹zania tego problemu: algorytm optymalny oraz algorytm z indeksem podobieñstwa.
\subsection{Algorytm optymalny}
W algorytmie optymalnym porównujemy nowy blok ze wszystkimi blokami, które posiadamy.
Jest on trudny do zastosowania w praktyce przez asymptotycznie liniowy czas dzia³ania ze wzglêdu na liczbê bloków w systemie (która w œrodowisku produkcyjnym mo¿e siêgaæ wielu milionów).
Jednak jest on dobrym punktem odniesienia dla innych algorytmów.
Pozwala znaleŸæ dolne ograniczenie na rozmiar danych potrzebnych do przes³ania w klasie algorytmów delta kodowania.

\begin{algorithmic}
\begin{algorithm}
\Function{optimalDeltaEncoding}{$blocks, block$}
\State $best\_block \gets blocks[0]$
\State $best\_diff \gets \Call{Diff}{block, blocks[0]}$
\For{$old\_block \ \textbf{in} \ blocks$}
    \State $diff \gets \Call{Diff}{block, old\_block}$
    \If{$\Call{length}{diff} < \Call{length}{best\_diff}$}
        \State $best\_diff \gets diff$
        \State $best\_block \gets old\_block$
    \EndIf
\EndFor
\State \Return $best\_block.getHash()$
\EndFunction
\end{algorithm}
\end{algorithmic}

\subsection{Indeks podobieñstwa}
W algorytmie z indeksem podobieñstwa stosujemy znacznie bardziej wyrafinowan¹ strategiê.
Dla ka¿dego bloku bêdziemy liczyæ okreœlon¹, sta³¹ liczbê $S \times K$ wartoœci zwanych cechami (ang. \textit{feature}).
W tym celu poruszamy siê po bloku oknem (ang. \textit{window}) o sta³ym rozmiarze $W$ i dla ka¿dego okna $w$ liczymy znacznik Rabina (ang. \textit{Rabin’s fingerprint}) $fp(w) = \sum\limits_{i=0}^{W-1} w[i] \times P^{i} \mod Q$, gdzie $P$ i $Q$ to ustalone liczby pierwsze.
Dla cechy o numerze $i$ definiujemy dwie wartoœci $m_i$ oraz $a_i$.
Wartoœci¹ cechy o numerze $i$ bêdzie minimum po wszystkich oknach $w$ z $(fp(w) \times m_i + a_i) \mod 2^{32}$.
Wartoœciami $a_i$ oraz $m_i$ powinny byæ du¿e, losowe liczby pierwsze.
Nastêpnie tworzymy super cechy (ang. \textit{superfeature}).
W tym celu dzielimy cechy bloku na grupy po $K$ kolejnych cech i dla ka¿dej z grup liczymy znacznik Rabina - jego wartoœæ bêdzie wartoœci¹ super cechy.
Algorytm zwróci stary blok, który ma najwiêcej wspólnych super cech z nowym blokiem.
Jeœli zaœ ¿aden stary blok nie ma wspólnych super cech z nowym blokiem, powinniœmy wys³aæ ca³y nowy blok.
Eksperymentalnie wyznaczyliœmy, ¿e najlepiej dzia³aj¹ wartoœci $K=4$ i $S=2$ - pod uwagê braliœmy iloœæ czasu potrzebn¹ na obliczenia, liczbê znajdowanych bloków oraz ich jakoœæ.
Oczywiœcie, im wiêksze $K$, tym lepsza jakoœæ kandydatów.
Z kolei im wiêksze $S$, tym wiêcej bloków znajdujemy.
Czas obliczeñ jest zaœ wprost proporcjonalny do $S \times K$.

\begin{algorithmic}
\begin{algorithm}
\Function{calculateFeatures}{$block$}
\State $N \gets S \times K$
\State $features[N] \gets {None, ... }$
\State $best[N] \gets {2^{32}, ... }$
\ForAll{window $w$ in $block$}
    \For{$i \ \textbf{in} \ \{0, ..., N - 1\}$}
        \State $value \gets m[i] \times \Call{fp}{w} + a[i] \mod 2^{32}$
        \If {$value < best[i]$}
            \State $best[i] \gets value$
            \State $feature[i] \gets \Call{fp}{w}$
        \EndIf
    \EndFor
\EndFor
\State \Return $features$
\EndFunction
\\
\Function{createSuperfeatures}{$features$}
\State $sfeatures[S] \gets 0, ...$
\For{$i \ \textbf{in} \ \{0, ... S - 1\}$}
    \For{$j \ \textbf{in} \ \{0, ..., K - 1\}$}
        \State $sfeatures[i] \gets sfeatures[i] \times P + features[i \times K + j] \mod Q$
    \EndFor
\EndFor
\State \Return $sfeatures$
\EndFunction
\\
\Function{similarityIndexEncoding}{$block, hashes\_map, sfeatures\_map$}
\State $features \gets \Call{calculateFeatures}{block}$
\State $sfeatures \gets \Call{createSuperfeatures}{features}$
\State $hashes \gets empty$ \Comment{wartoœci funkcji skrótu kandydatów na blok bazowy}
\For{$sfeature \ \textbf{in} \ sfeatures$}
    \State $hashes.add(hashes\_map[sfeature])$
\EndFor
\State $best \gets None$ \Comment{szukanie bloku z najwiêksz¹ liczb¹ wspólnych super cech}
\State $common \gets 0$
\For{$hash \ \textbf{in} \ hashes$}
    \State $common' \gets \Call{length}{sfeatures.intersect(sfeatures\_map[hash])}$
    \If {$common' > common$}
        \State $common \gets common'$
        \State $best \gets hash$
    \EndIf
\EndFor
\State $sfeatures\_map.add(block.getHash(), sfeatures)$ \Comment{aktualizowanie struktur danych}
\For{$sfeature \ \textbf{in} \ sfeatures$}
    \State $hashes\_map.add(sfeature, block.getHash())$
\EndFor
\State \Return $best$
\EndFunction
\end{algorithm}
\end{algorithmic}


\chapter{Funkcjonalnoœci}
Stworzony symulator umo¿liwia szybkie sprawdzanie efektywnoœci algorytmów delta kodowania dla ró¿nych danych wejœciowych.
Zale¿a³o nam, aby by³ intuicyjny i wygodny w u¿yciu, dlatego zosta³ wyposa¿ony w graficzny interfejs u¿ytkownika.
Za jego pomoc¹ mo¿na tworzyæ i uruchamiaæ eksperymenty, czyli pojedyncze symulacje, dla konkretnych danych i wybranych parametrów.
Przedstawimy listê najwa¿niejszych funkcjonalnoœci symulatora.
\begin{description}

        \item[Wybór algorytmu delta kodowania.] \hfill
        
        Zosta³y zaimplementowane algorytmy: bez delta kodowania, optymalny oraz z indeksem podobieñstwa.
	Symulator pozwala na przetestowanie tych algorytmów oraz udostêpnia intuicyjny interfejs programistyczny, dziêki czemu mo¿na w prosty sposób dodawaæ kolejne.
	 \begin{figure}[H]
            \centering
            \includegraphics[width=0.6\textwidth]{img/alg_choose.png}
            \caption{Wybieranie algorytmu delta kodowania}
            \label{fig:alg_choose}
        \end{figure}	
	
        \item[Kompresja danych przed przes³aniem.] \hfill
        
	Po zastosowaniu odpowiedniego algorytmu delta kodowania dane przed wys³aniem mog¹ byæ dodatkowo skompresowane przy u¿yciu LZO, ZIP lub LZMA.
	
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.6\textwidth]{img/compr_choose.png}
            \caption{Wybieranie kompresji}
            \label{fig:compr_choose}
        \end{figure}	
	
	
	\item[Asynchroniczna kolejka eksperymentów.] \hfill
	
	Interfejs graficzny pozwala na dodawanie dowolnej liczby eksperymentów, które wykonuj¹ siê po kolei.
	Symulacja jest realizowana przez oddzielny w¹tek, dziêki czemu interfejs graficzny nie jest blokowany.
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.6\textwidth]{img/app1.png}
            \caption{Kolejka eksperymentów}
            \label{fig:async_queue}
        \end{figure}	
	
	\item[Prezentacja wyników w formie wykresów.] \hfill
	
	Wyniki wykonanych eksperymentów mo¿na wyœwietliæ w postaci czytelnych i estetycznych wykresów.
	Dla ka¿dej z wersji wyœwietlany jest procentowy udzia³ duplikatów we wszystkich jej blokach.
	
        \begin{figure}[H]
            \centering
            \includegraphics[width=0.6\textwidth]{img/chart.png}
            \caption{Wykres stworzony przez symulator}
            \label{fig:chart}
        \end{figure}
        
	\item[Zliczanie odczytów i zapisów.] \hfill
	
	Symulator umo¿liwia liczenie, ile szacunkowo odczytów i zapisów na dysk wykonywa³by dla danej wersji ka¿dy z algorytmów delta kodowania.
	\item[Serializacja wyników.] \hfill
	
	W celu zwiêkszenia elastycznoœci i ergonomii symulatora mo¿na wczytywaæ i zapisywaæ do pliku wyniki wybranych eksperymentów.

\end{description}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{img/app2.png}
    \caption{Wybieranie eksperymentów do stworzenia wykresu. Mo¿na te¿ wczytaæ nowe eksperymenty z pliku lub zapisaæ istniej¹ce.}
    \label{fig:charts_panel}
\end{figure}

\chapter{Architektura}
Architektura symulatora oparta jest o wzorzec Model-View-Controller, zapewniaj¹cy niezale¿noœæ kodu odpowiedzialnego za interakcjê z u¿ytkownikiem od kodu zajmuj¹cego siê logik¹ biznesow¹ aplikacji.
Oprócz standardowych dla wzorca MVC czêœci: modelu, widoku i kontrolera, w architekturze naszego projektu mo¿emy wyró¿niæ modu³y Algorithms, Storage i Chunker.
Zale¿noœci miêdzy poszczególnymi komponentami pokazane s¹ na rysunku \ref{fig:architecture}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/Architecture.png}
    \caption{Schemat architektury}
    \label{fig:architecture}
\end{figure}

\section{Algorithms}
Jest to modu³ implementuj¹cy algorytmy delta kodowania, a tak¿e mechanizmy umo¿liwiaj¹ce ich testowanie.
Jest napisany w Pythonie z wyj¹tkiem czêœci algorytmu z indeksem podobieñstwa, która jest napisana w C.
Wykorzystuje modu³y Chunker i Storage.
\section{Model-View-Controller}
Przedstawimy w skrócie sposób realizacji wzorca MVC w naszym projekcie.
Opiszemy sposób komunikacji pomiêdzy modelami, widokami i kontrolerem.
Gdy u¿ytkownik wykonuje jak¹œ akcjê, odpowiedni widok powiadamia kontroler za pomoc¹ sygna³ów biblioteki wxPython.
Widoki dowiaduj¹ siê o zmianie modeli bezpoœrednio od kontrolera.
S¹ dwa sposoby, w jaki kontroler dostaje informacje o zmianie modeli.
Wiêkszoœæ modeli jest pasywna, czyli nie zmienia swojego stanu samoczynnie - kontroler od razu dowiaduje siê o zmianach.
Wyj¹tek to kolejka reprezentuj¹ca kolejne zadania do wykonania.
Jest modelem aktywnym, czyli takim który mo¿e zmieniæ swój stan niezale¿nie od akcji wykonywanych przez u¿ytkownika.
Do obs³ugi kolejki zastosowaliœmy bibliotekê Publisher pakietu wxPython, która pozwala na wysy³anie komunikatów do kontrolera, gdy kolejka ulega zmianie.

\section{Chunker}
Chunker jest modu³em umo¿liwiaj¹cym czytanie plików z danymi jako strumieñ bajtów i dzieleniem go na bloki zmiennej d³ugoœci.
Sk³ada siê z trzech czêœci: napisanej w C++ biblioteki statycznej dostarczonej przez firmê 9LivesData, zaimplementowanego przez nas adaptera w C++ oraz interfejsu w Pythonie.

\section{Storage}
Modu³ Storage odpowiada za gromadzenie bloków danych, wykrywanie duplikatów oraz zliczanie zapisów i odczytów.
Wprowadza abstrakcjê, pod któr¹ mo¿e kryæ siê zarówno implementacja u¿ywaj¹ca tylko pamiêci RAM, jak i wykorzystuj¹ca bazê danych.

\chapter{Technologie}
Bardzo du¿e znaczenie dla jakoœci systemu informatycznego maj¹ zastosowane technologie.
Ich wybór ma wp³yw na wydajnoœæ, ³atwoœæ pisania kodu, dostêpnoœæ bibliotek (w przypadku jêzyka programowania).
Podobnie by³o w przypadku symulatora, co zostanie pokazane w nastêpnych paragrafach.
\section{Jêzyki programowania}
W jêzyku C++ napisaliœmy adapter Chunkera.
By³o to wymuszone technologi¹, w jakiej zosta³ napisany Chunker.

Sam symulator zdecydowaliœmy siê napisaæ w jêzyku Python w wersji 2.7.
Wybraliœmy go ze wzglêdu na na mo¿liwoœæ szybkiego wytwarzania oprogramowania przy stosunkowo niewielkiej iloœci kodu Ÿród³owego.
Jednoczeœnie jest w nim dostêpnych wiele ró¿norodnych bibliotek, z których chcieliœmy skorzystaæ w naszym projekcie.
Niestety Python przy wszystkich swoich zaletach nie oferuje zbyt dobrej wydajnoœci.
Dlatego wymagaj¹ce obliczeniowo czêœci algorytmów zosta³y napisane w C.
Zrobiliœmy to, u¿ywaj¹c zbioru nag³ówków implementacji CPython.
Pozwoli³o to przyspieszyæ symulacjê kilkanaœcie razy.

Byæ mo¿e warto wyjaœniæ, dlaczego nie zdecydowaliœmy siê na wersjê Pythona z prefiksem 3.
Otó¿ nie jest ona kompatybilna wstecznie i dlatego u¿ycie wielu bibliotek, które s¹ dostêpne dla wersji 2.7, staje siê problematyczne.
Poza tym mieliœmy wiêcej doœwiadczenia z u¿ywaniem poprzednich wersji.

Mo¿e siê równie¿ nasuwaæ pytanie, dlaczego nie zastosowaliœmy implementacji Pythona o nazwie PyPy.
Jest ona wszak du¿o bardziej wydajna ni¿ popularny CPython.
Niestety u¿ywanie wielu pakietów, które zosta³y napisane w C (np. wxPython) jest w niej trudne lub wrêcz niemo¿liwe.
Nie jest te¿ ona do koñca kompatybilna z innymi implementacjami.
\section{Biblioteki}
\subsection{wxPython}
Obs³uga symulatora odbywa siê za pomoc¹ graficznego interfejsu u¿ytkownika stworzonego z u¿yciem pakietu wxPython.
Zosta³ zaimplementowany jako nak³adka na napisan¹ w C++ wieloplatformow¹ bibliotekê wxWidgets.
\subsection{Pygal}
Biblioteka ta umo¿liwia tworzenie wykresów w formacie SVG na podstawie ró¿norodnych statystyk opisuj¹cych wyniki eksperymentu.
\subsection{Virtualenv}
Jest to narzêdzie do tworzenia izolowanego œrodowiska dla aplikacji w Pythonie.
Umo¿liwia ono posiadanie lokalnych wersji bibliotek, które mog¹ byæ ró¿ne od tych globalnych.
Dziêki temu nasz symulator jest niezale¿ny od systemowych aktualizacji, a tak¿e od innych aplikacji w obrêbie systemu.
\subsection{Xdelta 3.0}
U¿yliœmy tej biblioteki do liczenia ró¿nic miêdzy plikami binarnymi.
Zosta³a napisana w C, dziêki czemu jest bardzo wydajna.
\subsection{Pylint}
Narzêdzie do statycznej analizy kodu Ÿród³owego w Pythonie, które zdecydowanie u³atwia dbanie o jego jakoœæ.
Sprawdza zgodnoœæ z zaleceniami PEP 8.
\subsection{PyLZMA}
Biblioteka do kompresji LZMA.

\chapter{Zarz¹dzanie projektem}
Sposób organizacji pracy zespo³u ma du¿y wp³yw na jakoœæ efektu koñcowego i terminowoœæ, dlatego nie powinien byæ przypadkowy.
Metodyk¹ pracy, na któr¹ siê zdecydowaliœmy by³o programowanie zwinne (ang. \textit{Agile software development}) z elementami kanbana.
Stosowaliœmy tak¿e technikê TDD (ang. \textit{Test-driven development}) oraz inspekcjê kodu (ang. \textit{Code review}).

\section{Programowanie zwinne}
Programowanie zwinne opiera siê na iteracyjno-przyrostowym tworzeniu oprogramowania.
Wa¿n¹ obserwacj¹ w tej metodyce jest to, ¿e wymagania klienta czêsto ewoluuj¹ w czasie trwania projektu.
Naturaln¹ konsekwencj¹ tej obserwacji jest wiêc ci¹g³a adaptacja specyfikacji i oprogramowania do zmieniaj¹cej siê sytuacji.
Komunikacja w zespole ma charakter bezpoœredni, co pozwala ograniczyæ potrzebê tworzenia rozbudowanej dokumentacji.

G³ównym powodem wybrania tej metodyki by³ nieprzesuwalny termin zakoñczenia projektu.
Ewentualne spóŸnienie mia³o du¿o powa¿niejsze konsekwencje ni¿ ograniczenie zakresu czy zmniejszenie jakoœci.
Drugim powodem by³o to, ¿e firma 9LivesData planowa³a zmieniaæ wymagania w zale¿noœci od kolejno osi¹ganych wyników.

Zgodnie z za³o¿eniami metodyki \textit{agile} nasza praca by³a podzielona na iteracje.
Na pocz¹tku ka¿dej z nich konsultowaliœmy siê z firm¹ w sprawie priorytetów na najbli¿szy czas.
Nastêpnie realizowaliœmy zadania pojedynczej iteracji zgodnie z za³o¿eniami Kanbana, co opiszemy poni¿ej.
Na zakoñczenie iteracji demonstrowaliœmy firmie dzia³aj¹c¹ wersjê produktu.

\section{Kanban}
Metodyka Kanban powsta³a na skutek zaadaptowania na potrzeby in¿ynierii oprogramowania opracowanej w Japonii metody sterowania produkcj¹.
G³ówne zasady Kanbana to wizualizacja, ograniczenie pracy w toku i zarz¹dzanie strumieniem.
Wizualizacja polega na przedstawieniu kolejnych etapów wykonywanych zadañ na tablicy.
Ka¿da z kolumn tablicy przedstawia jeden etap procesu i zawiera kartki z  konkretnymi zadaniami (wraz ze wskazaniem osób wykonuj¹cych je).
Ograniczenie pracy w toku sprowadza siê do ustalenia maksymalnej dopuszczalnej liczby zadañ, które mog¹ siê znajdowaæ w danej kolumnie tablicy.
Skraca to œredni czas realizacji zadania.
Z kolei zarz¹dzanie strumieniem polega na analizowaniu szybkoœci realizacji zadañ w celu optymalizacji pracy.
Kanban k³adzie te¿ du¿y nacisk na równomierne ob³o¿enie cz³onków zespo³u prac¹ i dlatego wprowadza siê te¿ czêsto ograniczenie liczby zadañ na osobê.
Pozwala to unikn¹æ sytuacji, gdy jeden cz³onek zespo³u zaczyna wykonywaæ wszystkie zadania na raz, blokuj¹c dzia³ania reszty.

Do utworzenia tablicy z zadaniami u¿yliœmy platformy Trello (rysunek \ref{fig:trello_screen}).
Kolejnymi kolumnami by³y: 
\begin{description}
\item[backlog] \hfill \\
    du¿e zadania czekaj¹ce na realizacjê
\item[next] \hfill \\
    zadania do wykonania w najbli¿szym czasie
\item[in progress] \hfill \\
    zadania w trakcie realizacji
\item[code review] \hfill \\
    zadania w trakcie inspekcji kodu
\item[done] \hfill \\
    wykonane zadania
\end{description}
Zadania powstawa³y poprzez dzielenie na mniejsze czêœci du¿ych zadañ wybieranych przez firmê na pocz¹tku iteracji.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/trello_screen.png}
    \caption{Platforma Trello do zarz¹dzania zadaniami}
    \label{fig:trello_screen}
\end{figure}

Aby ukazaæ pe³ny obraz pracy nad projektem, umieszczamy poni¿ej cykl ¿ycia pojedynczego zadania:
\begin{enumerate}
    \item Zadanie powstaje z du¿ego zadania opracowanego przez zamawiaj¹cego.
    \item Programista wybiera zadanie i przystêpuje do jego realizacji.
    \item Programista tworzy oddzieln¹ ga³¹Ÿ w repozytorium.
    \item Programista pisze testy i implementuje wymagane funkcjonalnoœci.
    \item \label{item:review}Kod podlega inspekcji przeprowadzonej przez cz³onka zespo³u innego ni¿ autor.
    \item Jeœli kod bêdzie zaakceptowany, idŸ do punktu \ref{item:merge}, w przeciwnym razie do punktu \ref{item:fix}.
    \item \label{item:fix} Programista poprawia kod zgodnie z uwagami recenzuj¹cego. PrzejdŸ do punktu \ref{item:review}.
    \item \label{item:merge}Programista do³¹cza kod do g³ównej ga³êzi projektu.
\end{enumerate}

\section{TDD}
Jest to technika tworzenia oprogramowania opieraj¹ca siê na nastêpuj¹cym schemacie.
Przed napisaniem fragmentu kodu programista materializuje wymagania funkcjonalne jako testy jednostkowe, które pocz¹tkowo ponosz¹ pora¿kê.
Nastêpnie doprowadza kod do takiego stanu, aby owe testy koñczy³y siê z sukcesem.
Stosowanie TDD skutkuje du¿ym pokryciem kodu testami i wczesnym wykrywaniem b³êdów.

\chapter{Podzia³ pracy}
\begin{center}
    \begin{longtable}{ | l | p{10cm} |}
    \nobreakhline
    Cz³onek zespo³u & Wykonane zadania \\* \nobreakhline
    Krzysztof Kiewicz &
    Integracja mo¿liwoœci testowania ca³ych katalogów/wersji z GUI. \newline
    Refaktoryzacja GUI.
    
    \\ \hline
    Pawe³ Kura & 
    Zaimplementowanie domyœlnego dodawania danych do Storage'u (algorytm naiwny). \newline
    Zaimplementowanie klasy FileProcessor, która przetwarza pliki i dodaje je do Storage'u. \newline
    Dodanie mo¿liwoœci testowania ca³ych katalogów i wersji. \newline
    Przygotowanie danych do testowania.
      
    \\ \hline
    Dawid £azarczyk &
    Zaimplementowanie komunikacji z Chunkerem. \newline
    Dodanie interfejsów do klasy ChunkUpdate, która reprezentuje ró¿nice miêdzy blokami. \newline
    Dodanie xdelta3. \newline
    Zaimplementowanie optymalnego algorytmu delta kodowania. \newline
    Generowanie wykresów dla wielu eksperymentów na raz. \newline
    Zaimplementowanie algorytmu z indeksem podobieñstwa. \newline
    Zaimplementowanie serializacji wyników.
    
    \\ \hline
    Marcel Ziêba &
    Przygotowanie œrodowiska - repozytorium, frameworku do testowania, narzêdzia do statycznej analizy kodu. \newline
    Zaimplementowanie podstawowych klas odpowiadaj¹cych za przechowywanie danych. \newline
    Zaimplementowanie podstawowej wersji GUI. \newline
    Dodanie kompresji LZO i ZIP. \newline
    Dodanie mo¿liwoœci generowania i wyœwietlania wykresów w GUI. \newline
    Dodanie asynchronicznego wykonywania eksperymentów. \newline
    Implementacja mierzenia kosztów operacji wejœcia-wyjœcia. \newline
    Przeprowadzenie eksperymentów i opracowanie wyników.
       
    \\ \hline
    \end{longtable}
\end{center}

\chapter{Wyniki symulacji}
W tym rozdziale przedstawimy wyniki eksperymentów przeprowadzonych przy pomocy symulatora.
Znalezienie odpowiednich danych do eksperymentów by³o istotn¹ czêœci¹ projektu.
Zestawy danych powinny byæ ró¿norodne i jak najbardziej zbli¿one do danych produkcyjnych.
Tylko wtedy mo¿na oczekiwaæ, ¿e uzyskane rezultaty s¹ dobr¹ aproksymacj¹ potencjalnych wyników systemu HYDRAstor.
Eksperymenty zosta³y przeprowadzone dla 4 zestawów danych: Ÿróde³ j¹dra Linuxa (2 zestawy), katalogów domowych i Ÿróde³ projektu Django.

\section{Format wyników}
Wyniki s¹ przedstawione w postaci wykresów s³upkowych.
Ka¿dy zestaw danych sk³ada siê z kilku wersji.
Dla ka¿dej z wersji na wykresie zosta³y umieszczone: procent duplikatów wœród jej bloków oraz s³upki z wynikami symulacji.
Ka¿dy ze s³upków dotyczy konkretnej metody przesy³ania danych.
Ka¿da z metod sk³ada siê z algorytmu delta kodowania oraz rodzaju kompresji i odpowiada jej jeden ustalony kolor s³upka.
Wysokoœæ s³upka okreœla, ile danych trzeba przes³aæ dla danej wersji danych i metody.

\section{Wyniki dla Ÿróde³ j¹dra Linuxa - ma³e odstêpy}
Pierwsza symulacja zosta³a przeprowadzona dla Ÿróde³ j¹dra Linuxa w trzech wersjach.
Kolejne wersje by³y oddalone od siebie o piêæ tysiêcy zmian (ang. \textit{commit}).
Rozmiar danych potrzebnych do przes³ania podczas replikacji zosta³ policzony dla szeœciu metod.

Metody wraz z oznaczaj¹cymi je kolorami:
\begin{itemize}
\item Czerwony - brak delta kodowania, brak kompresji
\item Zielony - brak delta kodowania, kompresja LZO. Jest to obecna metoda systemu HYDRAstor
\item ¯ó³ty - brak delta kodowania, kompresja LZMA
\item B³êkitny - indeks podobieñstwa, brak kompresji
\item Fioletowy - indeks podobieñstwa, kompresja LZO
\item Szary - indeks podobieñstwa, kompresja LZMA
\end{itemize}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/linuxSmall.png}
    \caption{Wyniki dla Ÿróde³ j¹dra Linuxa z ma³ymi odstêpami}
    \label{fig:linuxSmall}
\end{figure}

Zacznijmy od liczby duplikatów.
Dla pierwszej wersji jest to tylko 0.05\%, czyli prawie wszystkie bloki s¹ unikalne.
Dla drugiej wersji duplikaty stanowi¹ 8.05\% bloków.
Pomimo tego, ¿e wersje s¹ od siebie oddalone o tylko 5 tysiêcy zmian, wiêkszoœæ bloków jest inna.
Dla trzeciej wersji liczba usuniêtych duplikatów to nieco ponad 10\%.

Przeanalizujmy metody nie u¿ywaj¹ce delta kodowania.
S¹ one oznaczone kolorami: czerwonym, zielonym i ¿ó³tym.
Ró¿ni¹ siê jedynie typem kompresji u¿ytej przed wys³aniem danych.
Widzimy, ¿e w ka¿dej z trzech wersji kompresja LZO zmniejsza rozmiar danych o oko³o 74\%, zaœ kompresja LZMA o 84\%.
Sama zmiana rodzaju kompresji mo¿e wiêc w istotny sposób zwiêkszyæ efektywnoœæ replikacji.

Porównajmy teraz indeks podobieñstwa z brakiem delta kodowania dla ró¿nych rodzajów kompresji.
W pierwszej wersji wyniki siê prawie nie ró¿ni¹.
Wynika to ze zbyt ma³ej iloœci danych w systemie, aby indeks podobieñstwa znalaz³ podobne bloki.
Natomiast w przypadku wersji drugiej i trzeciej delta kodowanie daje du¿o lepsze rezultaty.
Przy braku kompresji indeks podobieñstwa musi wys³aæ o 60\% mniej danych ni¿ brak delta kodowania.
W przypadku kompresji LZO i LZMA jest to odpowiednio 54\% i 50\%.

Zauwa¿my, ¿e tak¿e w przypadku indeksu podobieñstwa u¿ycie kompresji LZMA daje du¿y zysk.
Dla kolejnych wersji rozmiar danych zostaje zmniejszony o odpowiednio 41\%, 34\% oraz 34\%.

\section{Wyniki dla Ÿróde³ j¹dra Linuxa - du¿e odstêpy}
Równie¿ drugi eksperyment zosta³ przeprowadzony dla Ÿróde³ j¹dra Linuxa.
W tym przypadku dane w kolejnych wersjach znacznie siê od siebie ró¿ni¹.
Ka¿da kolejna wersja jest odleg³a od poprzedniej o dwadzieœcia tysiêcy zmian.
Znaczenie kolorów jest takie samo jak w poprzednim eksperymencie.
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/linuxBig.png}
    \caption{Wyniki dla Ÿróde³ j¹dra Linuxa z du¿ymi odstêpami}
    \label{fig:linuxBig}
\end{figure}

Na pocz¹tku zauwa¿my, ¿e liczba duplikatów jest znacznie mniejsza ni¿ poprzednio.
Dla drugiej i trzeciej wersji znaleziono ich mniej ni¿ 2\%.

Indeks podobieñstwa radzi sobie zdecydowanie gorzej ni¿ w poprzednim eksperymencie.
W przypadku kompresji LZO zysk w stosunku do braku delta kodowania wynosi dla kolejnych wersji odpowiednio 1\%, 15\% i 9\%.
Natomiast dla kompresji LZMA jest to kolejno -0.1\%, 11\% i 9\%.
Z podobnych powodów jak poprzednio zysk w przypadku pierwszej wersji jest bliski zera.
Jednak dla drugiej i trzeciej wersji wyniki tego zestawu danych s¹ znacznie s³absze ni¿ poprzedniego.
Widaæ zatem, jak du¿y wp³yw na skutecznoœæ indeksu podobieñstwa ma czêstoœæ wykonywania replikacji.
\section{Wyniki dla kopii zapasowych katalogu domowego}
W tym eksperymencie u¿yliœmy danych z naszych katalogów domowych.
Kolejne wersje powstawa³y z kopii zapasowych wykonywanych co miesi¹c.

Znaczenie kolorów jest identyczne jak w poprzednich dwóch eksperymentach.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/backups.png}
    \caption{Wyniki dla kopii zapasowych katalogu domowego}
    \label{fig:backup}
\end{figure}

W przypadku katalogów domowych deduplikacja dzia³a znacznie lepiej.
Dla drugiej i trzeciej wersji liczba duplikatów to odpowiednio 64\% oraz 75\%.
Wynika to ze specyfiki sposobu u¿ytkowania katalogu domowego.
Wiêkszoœæ zmian polega na dodawaniu b¹dŸ usuwaniu ca³ych plików, modyfikacje s¹ rzadkoœci¹.
To t³umaczy, dlaczego indeks podobieñstwa nie daje praktycznie ¿adnego zysku.
Przy jego u¿yciu musielibyœmy przesy³aæ tyle samo danych co w przypadku obecnej wersji systemu HYDRAstor.

\section{Wyniki dla Ÿróde³ projektu Django}
Kolejny zestaw danych to Ÿród³a projektu Django.
G³ównym powodem wyboru tego zestawu by³ jego niewielki rozmiar (kilkadziesi¹t megabajtów).
Dziêki temu mo¿emy porównaæ indeks podobieñstwa z optymalnym delta kodowaniem.
Podobnie jak poprzednio, przygotowaliœmy trzy wersje danych.
Kolejne wersje ró¿ni³y siê o 500 zmian.
Tym razem wp³yw typu kompresji na wyniki nie by³ przedmiotem naszego zainteresowania, dlatego wszystkie metody stosuj¹ kompresjê LZO.

Znaczenie kolorów:
\begin{itemize}
\item Czerwony - brak delta kodowania, kompresja LZO
\item Zielony - optymalne delta kodowanie, kompresja LZO
\item ¯ó³ty - indeks podobieñstwa, kompresja LZO
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{img/django.png}
    \caption{Wyniki dla projektu Django}
    \label{fig:django}
 \end{figure}
Liczby duplikatów w kolejnych wersjach to 0\%, 35.7\% i 4.4\%.
Zmiany w drugiej wersji by³y wiêc stosunkowo ma³e.
Natomiast w trzeciej by³y znacznie wiêksze.

Tradycyjnie w przypadku pierwszej wersji nie ma wiêkszych ró¿nic miêdzy wynikami.
Dla drugiej i trzeciej wersji optymalne delta kodowanie daje odpowiednio 87\% i 68\% zysku wzglêdem braku delta kodowania.
Natomiast dla indeksu podobieñstwa jest to 66\% i 47\%.
Ró¿nice miêdzy indeksem podobieñstwa a algorytmem optymalnym s¹ ca³kiem du¿e.
Optymalizowanie indeksu podobieñstwa jest wiêc w pe³ni uzasadnione.

\section{Zbiorcze wyniki}
Poni¿sza tabela przedstawia zbiorcze wyniki eksperymentów.
Dla ka¿dego zestawu danych i metody zosta³ obliczony rozmiar danych potrzebnych do przes³ania we wszystkich wersjach.
Tabelê powinno siê analizowaæ kolumnami.
Jedna kolumna przedstawia wyniki dla jednego zestawu danych przy u¿yciu ró¿nych metod.

\begin{tabular}{|c|c|c|c|c|c|}
\cline{1-6}
 & & \multicolumn{4}{ c| }{Dane testowe} \\
Delta kodowanie & Kompresja & \multicolumn{2}{ c| }{J¹dro linuxa} & Katolog domowy & Django \\
 &  & 5k odstêpy & 20k odstêpy &  &  \\
\cline{1-6}
\multicolumn{1}{ |c  }{\multirow{3}{*}{Brak} } &
\multicolumn{1}{ |c| }{Brak} & 658MB & 1052MB & 660MB & N/A    \\ 
\cline{2-6}
\multicolumn{1}{ |c  }{}                        &
\multicolumn{1}{ |c| }{LZO} & 174MB & 271MB & 450MB & 19.162MB  \\ 
\cline{2-6}
\multicolumn{1}{ |c  }{}                        &
\multicolumn{1}{ |c| }{LZMA} & 103MB & 160MB & 400MB & N/A \\ 
\cline{1-6}
\multicolumn{1}{ |c  }{\multirow{3}{*}{Indeks podobieñstwa} } &
\multicolumn{1}{ |c| }{Brak} & 396MB & 941MB & 566MB & N/A     \\ 
\cline{2-6}
\multicolumn{1}{ |c  }{}                        &
\multicolumn{1}{ |c| }{LZO} & 110MB & 248MB & 446MB & 12.708MB      \\ 
\cline{2-6}
\multicolumn{1}{ |c  }{}                        &
\multicolumn{1}{ |c| }{LZMA} & 68MB & 149MB & 400MB & N/A      \\ 
\cline{1-6}
\multicolumn{1}{ |c  }{\multirow{3}{*}{Optymalne} } &
\multicolumn{1}{ |c| }{Brak} & N/A & N/A & N/A & N/A     \\ 
\cline{2-6}
\multicolumn{1}{ |c  }{}                        &
\multicolumn{1}{ |c| }{LZO} & N/A & N/A & N/A & 10.206MB      \\ 
\cline{2-6}
\multicolumn{1}{ |c  }{}                        &
\multicolumn{1}{ |c| }{LZMA} & N/A & N/A & N/A & N/A      \\ 
\cline{1-6}
\end{tabular}
\\

\section{Porównanie z innymi publikacjami}
W pracy Philipa Shilane'a i innych (\cite{work1}) wykonywano podobne eksperymenty, jednak k³adziono nacisk na odrobinê inne aspekty.
Badano tam m. in. sposób odwzorowywania super cech na bloki - porównywano indeks pe³ny, czêœciowy oraz lokaln¹ dla strumienia pamiêæ podrêczn¹.
W naszych eksperymentach jednak nie by³o to istotne, dlatego weŸmiemy pod uwagê jedynie wyniki dla indeksu pe³nego.
Warto dodaæ, ¿e mieliœmy trochê inn¹ konfiguracjê symulatora ni¿ autorzy tej pracy.
Przeciêtny rozmiar bloku w wy¿ej wymienionej pracy to 8KB, z kolei u nas to 64KB.
Jednoczeœnie koñcowe eksperymenty przeprowadzano tam z 3 super cechami na blok, u nas z 2.
Kolejn¹ ró¿nic¹ jest rozmiar danych.
Nasze dane testowe by³y rzêdu setek megabajtów, w ich pracy - rzêdu terabajtów.
Inaczej te¿ wykonywaliœmy kompresjê -  u nas mia³a ona charakter globalny, u nich lokalny.
U¿yliœmy równie¿ innego Chunkera.
Ró¿nice te mog³y znacznie wp³yn¹æ na wyniki eksperymentów.

PrzejdŸmy do porównania wyników.
Dla kodów Ÿród³owych uzyskano tam samym delta kodowaniem poprawê rzêdu 73\%.
Przypomnijmy, ¿e my osi¹gnêliœmy wynik 50\% i oko³o 10\% w zale¿noœci od czêstoœci wykonywania kopii zapasowych.
Dla stacji roboczych osi¹gniêto zysk rzêdu 65\%, u nas by³ on symboliczny.

Nale¿y przypuszczaæ, ¿e porównanie wypad³oby odrobinê inaczej, gdybyœmy przeprowadzili eksperymenty bardziej zbli¿one do tych z pracy Shilane'a i innych.
Jednak kluczowe by³o dla nas i firmy 9LivesData, aby konfiguracja jak najbardziej odwzorowywa³a warunki pracy systemu HYDRAstor.

\chapter{Podsumowanie}
Przeprowadzone eksperymenty pokaza³y, ¿e efektywnoœæ delta kodowania w bardzo du¿ym stopniu zale¿y od rodzaju danych.
Najlepsze wyniki osi¹galiœmy, gdy kolejne wersje danych ma³o siê od siebie ró¿ni³y, co jest zgodne z oczekiwaniami.
A wiêc jest du¿a szansa, ¿e indeks podobieñstwa siê sprawdzi, jeœli kopie zapasowe bêd¹ wykonywane czêsto.
Du¿e znaczenie ma te¿ sposób modyfikacji danych.
Zysk jest bardzo du¿y, gdy wprowadza siê niewielkie zmiany w wielu plikach.
Z kolei dane zmieniaj¹ce siê w sposób przyrostowy mog¹ nie dawaæ zbyt dobrych wyników.
Decyzji o ewentualnym zastosowaniu delta kodowania powinna wiêc towarzyszyæ dok³adna analiza danych produkcyjnych.
Mo¿e siê okazaæ, ¿e uzyskana œrednia redukcja rozmiaru danych jest na tyle ma³a, ¿e nie ma sensu obci¹¿aæ systemu skomplikowanym i intensywnym obliczeniowo algorytmem.
Niezale¿nie od algorytmów delta kodowania warto badaæ sposób kompresowania danych.
Przy niewielkich nak³adach pracy mo¿na uzyskaæ lepsze rezultaty stosuj¹c kompresjê LZMA.

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem{work1} P. Shilane, M. Huang, G. Wallace, W. Hsu, \textit{WAN-optimized replication of backup datasets using stream-informed delta compression.} TOS 8(4): 13 (2012)

\bibitem{work2} P. Shilane, M. Huang, G. Wallace, W. Hsu, \textit{Delta Compressed and Deduplicated Storage
Using Stream-Informed Locality}, HotStorage (2012).

\bibitem{work3} T. Suel, N. Memon, \textit{Algorithms for Delta Compression and Remote File
Synchronization}, CIS Department
Polytechnic University
Brooklyn, NY 11201 (2002).

\bibitem{wxPython} wxPython Team, \textit{Dokumentacja wxPython}, \url{http://wxpython.org/Phoenix/docs/html/main.html} [21.01.2015r.]

\bibitem{xDelta} J. MacDonald \textit{xdelta}, \url{http://xdelta.org/} [21.01.2015r.]
\bibitem{HYDRAstor} 9LivesData \textit{HYDRAstor}, \url{http://www.9livesdata.com/hydrastor.html}

\end{thebibliography}

\appendix
\chapter*{Dodatek A}
Na p³ycie CD-ROM do³¹czonej do niniejszej pracy znajduj¹ siê:
\[
	\begin{tabular}{c|c}
		Kod Ÿród³owy symulatora wraz z testami & ./deltacompression/ \\ \hline
		Skrypt przygotowuj¹cy dane testowe & ./tools/ \\ \hline
		Kod Ÿród³owy pracy licencjackiej & ./thesis/ \\ \hline
		Dokumentacja instalacji & ./README.md
	\end{tabular}
\]

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
