% Niniejszy plik stanowi przyk³ad formatowania pracy magisterskiej na Wydziale MIM UW.  Szkielet u¿ytych poleceñ mo¿na wykorzystywaæ do woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrze¿one.
%
% Copyright (c) 2001 by Marcin Woliñski <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Kar³owicz, 05.05.2006
% dodaj opcjê [licencjacka] dla pracy licencjackiej
\documentclass[licencjacka]{styles}

\usepackage{polski}
\usepackage{url}
\usepackage{graphicx}
\usepackage{pgffor}
\urlstyle{same}

%Jesli uzywasz kodowania polskich znakow ISO-8859-2 nastepna linia powinna byc odkomentowana
%\usepackage[latin2]{inputenc}
%Jesli uzywasz kodowania polskich znakow CP-1250 to ta linia powinna byc  odkomentowana
\usepackage[cp1250]{inputenc}

% Uwaga: ka¿dy z nas czworga ma oddzielny egzemplarz i wpisuje swoje dane
\author{Imiê i nazwisko}

\nralbumu{6 cyfr}

\title{Optymalizacja ruchu sieciowego w symulowanym systemie rozproszonych kopii zapasowych}

\tytulang{Optimization of network traffic in distributed backup systems}

\kierunek{Informatyka}

% Praca wykonana pod kierunkiem:
% (podaæ tytu³/stopieñ imiê i nazwisko opiekuna
% Instytut
% ew. Wydzia³ ew. Uczelnia (je¿eli nie MIM UW))
\opiekun{dra Roberta D¹browskiego\\
  Instytut Informatyki\\
  }

% miesi¹c i~rok:
\date{Czerwiec 2015}

%Podaæ dziedzinê wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
11.3 Informatyka\\ 
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{
	10002951 Information systems\\
	10002951.10003152.10003517.10003519 Distributed storage\\
  10002951.10002952.10002971.10003451.10002975 Data compression
  }
% S³owa kluczowe:
\keywords{delta kodowanie, indeks podobieñstwa, optymalizacja ruchu sieciowego, rozproszony system kopii zapasowych}

% Tu jest dobre miejsce na Twoje w³asne makra i~œrodowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
W pracy przedstawiono opis symulatora rozproszonych kopii zapasowych, algorytmów delta kodowania oraz wyniki przeprowadzonych eksperymentów.
Symulator naœladuje pracê systemu HYDRAstor oraz pozwala na zbadanie wp³ywu wdro¿enia nowych rozwi¹zañ na wydajnoœæ systemu.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables



\chapter*{Wstêp}
\addcontentsline{toc}{chapter}{Wstêp}
W wielu wspó³czesnych systemach kopii zapasowych w¹skim gard³em procesu replikacji jest przesy³anie danych ³¹czem internetowym.
W minimalizacji ich rozmiaru niew¹tpliwie pomaga dzielenie strumienia danych na bloki zmiennej d³ugoœci i u¿ywanie haszowania do eliminacji duplikatów.
Jednak to podejœcie ma swoje ograniczenia. W przypadku du¿ego rozmiaru bloku jest bardzo prawdopodobne, ¿e znajd¹ siê 2 prawie identyczne bloki, a istniej¹cy system tego nie wykryje i bêdzie przechowywa³ oba, co jest zachowaniem dalekim od optymalnego.
\\*
Sposobem na poprawienie tego jest zastosowanie delta kodowania z u¿yciem indeksu podobieñstwa.
Polega to na obliczaniu w okreœlony sposób cech ka¿dego unikalnego bloku, a przy dodawaniu nowego bloku sprawdzaniu, czy istnieje blok podobny do niego.
Miêdzy podobnymi blokami oblicza siê ró¿nicê o rozmiarze zazwyczaj zdecydowanie mniejszym od rozmiaru ca³ego bloku.
\\*
Zastosowanie tego pomys³u w istniej¹cym systemie kopii zapasowych wymaga ogromnych nak³adów pracy i nie daje ¿adnych gwarancji.
Z tego powodu na zlecenie firmy 9LivesData stworzyliœmy symulator jej systemu HYDRAstor, aby du¿o mniejszym wysi³kiem uzyskaæ informacjê, jakiego rzêdu zysków nale¿y siê spodziewaæ.
Stworzony symulator pozwala na badanie wp³ywu kilku czynników na iloœæ przesy³anych danych.
Badane jest znaczenie kompresji, rozmiaru bloku, a przede wszystkim samego delta kodowania.
Jednoczeœnie symulator stosuje mechanizmy oryginalnego systemu: dzielenie na bloki zmiennej d³ugoœci i wykrywanie duplikatów.

\chapter{System HYDRAstor}
Naszym zadaniem jest symulacja systemu HYDRAstor, wiêc nale¿y w skrócie opowiedzieæ jego dzia³anie.
Oczywiœcie symulator naœladuje pracê tego systemu jedynie z pewnym przybli¿eniem - w rzeczywistoœci jest on du¿o bardziej z³o¿ony.
Pogl¹dowy rysunek przedstawia pracê tego systemu.
\section{Bloki zmiennej d³ugoœci}
Bloki zmiennej d³ugoœci pozwalaj¹ w znacznym stopniu zmniejszyæ rozmiar danych, które zostan¹ przes³ane podczas replikacji, czyli procesu tworzenia nowej kopii.
Za³ó¿my chwilowo, ¿e stosujemy bloki sta³ej wielkoœci i mamy na serwerze strumieñ danych o bardzo du¿ym rozmiarze.
Nastêpnie w œrodku tego strumienia zostaje dodany jeden znak.
Sprawia to, ¿e po³owa strumienia zostanie podzielona na zupe³nie nowe bloki, mimo ¿e dane siê praktycznie nie zmieni³y.
Stosowanie bloków zmiennej d³ugoœci w po³¹czeniu z komponentem zwanym chunkerem, który wybiera granice bloków na podstawie samych danych, stosuj¹c pewne heurystyki, pozwala unikn¹æ tego problemu.
W powy¿szym przyk³adzie zadzia³a³by tak, ¿e kilka bloków po nowym znaku by³oby innych, ale reszta nie zmieni³aby siê.
\section{Deduplikacja}
Dla ka¿dego z nowo dodanych bloków jest tworzony identyfikator za pomoc¹ jednej z popularnych funkcji skrótu.
Pozwala to na eliminacjê duplikatów ze zbioru przechowywanych bloków.
Ma to du¿e znaczenie praktyczne, jeœli kopie s¹ wykonywane czêsto i dane w wiêkszoœci siê nie zmieniaj¹.
\section{Kompresja}
Przed przes³aniem bloki s¹ poddawane dzia³aniu algorytmowi kompresji, co pozwala znacz¹co zmieniæ rozmiar danych.
Stosowany algorytm kompresji musi nie tylko mieæ dobry wspó³czynnik kompresji, ale te¿ nie zu¿ywaæ zbyt du¿o zasobów.
\foreach \n in {1, ..., 8} {
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{img/visualization/\n.png}
    \caption{HYDRAstor \n}
    \label{fig:hydra\n}
\end{figure}
}

\chapter{Delta kodowanie}
Delta kodowanie sprowadza siê do dwóch zasadniczych problemów: znajdowania podobnych bloków i liczenia ró¿nic miêdzy nimi.
\section{Liczenie ró¿nic}
Jest to popularny w informatyce problem, aby na podstawie dwóch fragmentów danych stworzyæ ró¿nicê (ang. delta), dziêki której maj¹c tylko pierwszy fragment i ow¹ ró¿nicê, mo¿na  by³o odtworzyæ drugi fragment. Oczywiœcie rola owych fragmentów nie jest symetryczna - liczymy ró¿nicê jednego wzglêdem drugiego. Powsta³ szereg algorytmów, które siê tym zajmuj¹.
\\*
Jeden z nich implementuje popularny program Diff z systemów Unix. Jednak nie jest dobrym kandydatem do naszego problemu, gdy¿ porównuje pliki na poziomie linii, co ma szanse siê sprawdziæ jedynie dla w¹skiego zbioru plików tekstowych.
Interesuj¹ nas przede wszystkim algorytmy przeznaczone do liczenia ró¿nic miêdzy danymi binarnymi. Ograniczymy siê jednak do algorytmu xdelta3, którego u¿ywamy w symulatorze.
W du¿ym uproszczeniu jego dzia³anie polega na odtwarzaniu po kolei pliku, wykonuj¹c kilka operacji:
\begin{itemize}
\item wstawienie danego ci¹gu bajtów
\item skopiowanie ci¹gu bajtów z odtworzonego ju¿ fragmentu
\item skopiowanie ci¹gu bajtów z bazowego fragmentu
\end{itemize}

\section{Znajdowanie podobnych bloków}
W symulatorze zaimplementowaliœmy dwa ró¿ne podejœcia do tego problemu.
\begin{itemize}
\item
W algorytmie optymalnym porównujemy nowy blok ze wszystkimi blokami, które posiadamy. Jest on jednak niestosowalny w praktyce ze wzglêdu na asymptotycznie kwadratowy czas dzia³ania ze wzglêdu na iloœæ bloków. Jednak jest on dobrym punktem odniesienia do innych algorytmów - daje on informacjê, jakie jest dolne ograniczenie na rozmiar danych w klasie algorytmów delta kodowania porównuj¹cych z jednym blokiem.
\item
W algorytmie z indeksem podobieñstwa stosujemy zdecydowanie bardziej wyrafinowan¹ strategiê. Dla ka¿dego bloku bêdziemy liczyli okreœlon¹, sta³¹ iloœæ $K$ wartoœci liczbowych zwanych cechami (ang. feature). W tym celu poruszamy siê po bloku oknem (ang. window) o sta³ym rozmiarze $W$ i dla ka¿dego okna $w$ liczymy znacznik Rabina (ang. Rabin’s fingerprint) $fp(w)$. Dla cechy o numerze $i$ definiujemy dwie wartoœci $m_i$ oraz $a_i$. Wartoœci¹ cechy o numerze $i$ bêdzie minimum po wszystkich oknach $w$ z $(fp(w) * m_i + a_i) \ mod \ 2^{32}$. Wartoœciami $a_i$ oraz $m_i$ powinny byæ du¿e, losowe liczby pierwsze, jednak w celu zapewnienia powtarzalnoœci eksperymentów s¹ one w naszym symulatorze ustalone. Nastêpnie tworzymy supercechy (ang. superfeature) z ustalonej liczby $S$ zwyk³ych cech. W tym celu dzielimy cechy danego bloku na grupy po $K$ kolejnych cech i dla ka¿dej z grup liczymy znacznik Rabina - jego wartoœæ bêdzie wartoœci¹ danej supercechy. Wszystkie znaczniki liczymy przy u¿yciu du¿ych liczb pierwszych $P$ i $Q$. Aby znaleŸæ podobny blok do danego, wybieramy taki, który ma najwiêcej wspólnych super cech (jeœli jest takich wiêcej, wybieramy dowolny). Jeœli zaœ nie ma bloku z jak¹kolwiek wspóln¹ super cech¹, wysy³amy ca³y blok. Eksperymentalnie wyznaczyliœmy, ¿e najlepiej dzia³aj¹ wartoœci $K=4$ i $S=2$ - pod uwagê braliœmy iloœæ czasu potrzebn¹ na obliczenia, iloœæ znajdowanych bloków oraz ich jakoœæ. Oczywiœcie, im wiêksze $K$, tym lepsza jakoœæ kandydatów. Z kolei, im wiêksze $S$, tym wiêcej bloków znajdujemy. Czas obliczeñ jest zaœ wprost proporcjonalny do $S * K$.
\end{itemize}

\chapter{Funkcjonalnoœci systemu}

\begin{itemize}
        \item Mo¿liwoœæ wyboru sposobu przechowywania kopii zapasowych.
	
	Symulator zosta³ zaprojektowany w sposób, który pozwala na wybranie czy ma u¿ywaæ tylko pamiêci RAM, czy te¿ dysku b¹dŸ rozproszonej bazy danych typu klucz-wartoœæ.
	Pozwala to na wykonywanie zarówno ma³ych testów, które dzia³aj¹ szybko w pamiêci RAM jak i du¿ych testów, które wymagaj¹ znacznie wiêkszej iloœci pamiêci.
	
	
        \item Symulowanie replikacji bez u¿ycia delta kodowania, z u¿yciem optymalnego delta kodowania oraz z heurystycznym delta kodowaniem.
  
        System pozwala na przetestowanie zaimplementowanych algorytmów oraz udostêpnia intuicyjny interfejs programistyczny dziêki czemu mo¿na w prosty sposób rozszerzaæ o kolejne algorytmy.	
	
        \item Kompresja danych przed przes³aniem.
	
	Po zastosowani odpowiedniego algorytmu dane przed wys³aniem mog¹ byæ dodatkowo kompresowane przy pomocy lzo, zip lub lzma.
	
        \item Wygodny graficzny interfejs u¿ytkownika
	
	Za pomoc¹ graficznego interfejsu u¿ytkownik mo¿e wybraæ interesuj¹ce go konfiguracje, które chce przetestowaæ oraz wygenerowaæ wykres przedstawiaj¹cy wyniki.
	
	\item Prezentacja wyników w formie wykresów
	
	Wyniki wykonanych symulacji mo¿na wyœwietliæ w postaci interaktywnych wykresów.
	S¹ one œwietnym narzêdziem, które umo¿liwia zbadanie faktycznych rezultatów symulacji.
	
	\item Serializacja wyników danych.
	
	W celu zwiêkszenia elastycznoœci i ergonomii systemu mo¿na wczytywaæ i zapisywaæ do pliku wyniki wybranych eksperymentów.
\end{itemize}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/app1.png}
    \caption{Ekran tworzenia eksperymentu}
    \label{fig:experiment_screen}
\end{figure}	
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/app2.png}
    \caption{Ekran tworzenia wykresu}
    \label{fig:chart_screen}
\end{figure}


\chapter{Architektura}
\section{Model MVC}
Architektura tworzonego przez nas symulatora oparta jest o wzorzec Model-View-Controller, zapewniaj¹cy niezale¿noœæ kodu odpowiedzialnego za interakcjê z u¿ytkownikiem i kodu zajmuj¹cego siê logik¹ biznesow¹ aplikacji.
Oprócz standardowych dla wzorca MVC czêœci: model, widok i kontroler w architekturze naszego projektu mo¿emy wyró¿niæ Storage - osobn¹ czêœæ odpowiedzialn¹ za sk³adowanie danych w trakcie trwania symulacji oraz Chunker - czêœæ przetwarzaj¹c¹ pliki z dysku twardego.
Zale¿noœci miêdzy poszczególnymi komponentami pokazane s¹ na poni¿szym schemacie.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{img/Architecture.png}
    \caption{Schemat architektury}
    \label{fig:architecture}
\end{figure}

\section{Chunker}
Chunker jest osobnym modu³em zajmuj¹cym siê dzieleniem plików na bloki zmiennej d³ugoœci w taki sposób, aby wprowadzenie modyfikacji w pliku nie wymaga³o przes³ania du¿ej iloœci danych.
Zosta³ nam dostarczony przez firmê 9LivesData.

\section{Storage}
Storage odpowiada za gromadzenie bloków danych powsta³ych w trakcie fazy dzielenia plików przez Chunker.
Ta czêœæ jest wa¿na, poniewa¿ istot¹ algorytmów delta kodowania jest zapisywanie nowych bloków bazuj¹c na podobnych, istniej¹cych ju¿ blokach.

\chapter{Wyniki symulacji}
\section{Format wyników}
Wyniki s¹ przedstawione w formie wykresów s³upkowych.
Jeden kolor odpowiada jednej metodzie przesy³ania danych.
Przyk³adowo kolor czerwony mo¿e odpowiadaæ metodzie przesy³ania kolejnych wersji, w której usuwamy duplikaty, ale nie kompresujemy danych przed przes³aniem.
Ka¿dy s³upek danego koloru okreœla ile danych trzeba przes³aæ dla kolejnych wersji danych wejœciowych.
\section{Wyniki dla Ÿróde³ j¹dra Linuxa - ma³e odstêpy}
Pierwsza symulacja zosta³a przeprowadzona dla Ÿróde³ j¹dra Linuxa.
Zosta³y przygotowane trzy wersje Ÿróde³ j¹dra Linuxa oddalone od siebie o kilka tysiêcy zmian. Rozmiar danych potrzebnych do przes³ania zosta³a policzona dla czterech metod. 
Oznaczenia:
\begin{itemize}
\item Jasnym czerwonym - proste usuwanie duplikatów, brak kompresji
\item Zielony - proste usuwanie duplikatów, kompresja zip
\item ¯ó³ty - indeks podobieñstwa, brak kompresji
\item Niebieski - indeks podobieñstwa, kompresja zip
\end{itemize}
Porównajmy najistotniejsze metody, czyli zielon¹ i niebiesk¹.
Dla pierwszej wersji w obu przypadkach trzeba przes³aæ prawie tyle samo danych - oko³o 51 MB.
W przypadku drugiej wersji metoda z indeksem podobieñstwa jest znacznie lepsza, pozwala zmniejszyæ dane do przes³ania o prawie 75\%, a dla trzeciej wersji oko³o 70\%.
Oko³o 40\% w drugiej i trzeciej wersji nie musia³o byæ przes³anych dziêki deduplikacji.
Tak dobry wynik jest rezultatem tego, ¿e wersje danych nie s¹ zbytnio oddalone od siebie, dziêki czemu indeks podobieñstwa znajduje wiele podobnych bloków.
\section{Wyniki dla Ÿróde³ j¹dra Linuxa - du¿e odstêpy}
W przypadku du¿ych odstêpów miêdzy wersjami Ÿróde³ j¹dra Linuxa indeks podobieñstwa nie dzia³a ju¿ tak dobrze.
Kolejne wersje s¹ odleg³e od siebie o kilkadziesi¹t tysiêcy zmian przez co czêœæ plików nie zmienia siê w ogóle i wtedy bardzo dobrze dzia³a deduplikacja, a czêœæ zmienia siê tak bardzo, ¿e indeks podobieñstwa nie znajduje podobnych bloków.
Z tych dwóch powodów indeks podobieñstwa dla danych, które nie maj¹ ze sob¹ du¿o wspólnego daje bardzo marne wyniki.
\section{Wyniki dla Ÿróde³ ma³ego projektu torch}
Wa¿ne jest równie¿ jak indeks podobieñstwa dzia³a w porównaniu z optymalnym algorytmem delta kodowania
Pokazuje to kolejny eksperyment.
\begin{itemize}
\item Jasny czerwony - proste usuwanie duplikatów, kompresja zip
\item Zielony - optymalny algorytm delta kodowania, kompresja zip
\item ¯ó³ty - indeks podobieñstwa, kompresja zip
\end{itemize}
\chapter{Technologie}

\section{Jêzyki programowania}
System zosta³ napisany g³ównie w jêzyku Python w wersji 2.7. W jêzyku C++ zosta³ napisany adapter Chunkera. Z kolei wymagaj¹ca obliczeniowo czêœæ delta kodowania z indeksem podobieñstwa zosta³a napisana w C.

\section{Biblioteki}
Obs³uga symulatora odbywa siê za pomoc¹ graficznego interfejsu u¿ytkownika stworzonego z u¿yciem pakietu wxPython.
Po przeprowadzonej symulacji generowane s¹ ró¿norodne statystyki opisuj¹ce wyniki eksperymentu i wyœwietlane w zwizualizowanej formie, zosta³o to zrealizowane dziêki pygal - bibliotece do tworzenia wykresów w formacie SVG.

\section{Baza danych}
Wybraliœmy MongoDB, jest to nierelacyjna baza danych, która umo¿liwia efektywne przechowywanie danych typu klucz-wartoœæ, w naszym przypadku kluczem jest hash, a wartoœci¹ jest ca³y blok o danym hashu.

\chapter{Organizacja pracy}

\section{System kontroli wersji}
Tworzona przez nas aplikacja jest rozwijana z pomoc¹ systemu kontroli
wersji git.
Korzystamy ze zdalnego repozytorium na serwisie github.com.
\section{Metodyka pracy}
Pracujemy w metodyce agile z dodatkiem kanbana.
Zespó³ spotyka siê co tydzieñ, aby ustaliæ priorytety na najbli¿sze 2 tygodnie, podzieliæ siê prac¹ i omówiæ wyniki dotychczasowych dzia³añ.
Otrzymujemy odgórne wytyczne co do kszta³tu aplikacji od firmy zewnêtrznej ("du¿e zadania"),
które realizujemy mniejszymi fragmentami ("ma³e zadania").
Ka¿de z mniejszych zadañ jest realizowane przez jednego z cz³onków zespo³u.
Do zarz¹dzania zadaniami u¿ywamy systemu Trello.

\section{Realizacja pojedynczego zadania}
Zadanie jest wybierane przez cz³onka zespo³u, tworzona jest oddzielna
ga³¹Ÿ, zadanie jest realizowane, potem zaœ testowane.
PóŸniej kod podlega inspekcji przeprowadzonej przez innego cz³onka zespo³u.
Przy koniecznoœci wprowadzenia poprawek kod wraca do autora i s¹ one przez niego nanoszone.
Po inspekcji zakoñczonej sukcesem autor wciela kod do g³ównej ga³êzi projektu.

\section{Tworzenie oprogramowania oparte o testy}
Stosujemy tzw. TDD (ang. Test Driven Development) - przed napisaniem fragmentu
kodu programista materializuje wymagania funkcjonalne jako testy jednostkowe
pocz¹tkowo ponosz¹ce pora¿kê, a nastêpnie doprowadza kod do takiego stanu, aby owe testy koñczy³y siê z
sukcesem.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/trello_screen.png}
    \caption{System Trello do zarz¹dzania zadaniami}
    \label{fig:trello_screen}
\end{figure}
\chapter{Podzia³ pracy}

\begin{center}
    \begin{tabular}{ | l | p{10cm} |}
    \hline
    Cz³onek zespo³u & Wykonane zadania \\ \hline
    Krzysztof Kiewicz &
    Integracja mo¿liwoœci testowania ca³ych katalogów/wersji z GUI. \newline
    Refaktoryzacja GUI.
    
    \\ \hline
    Pawe³ Kura & 
    Zaimplementowanie domyœlnego dodawania danych do Storage'u (algorytm naiwny). \newline
    Zaimplementowanie klasy FileProcessor, przetwarzaj¹cej pliki i dodaj¹cej je do Storage'u. \newline
    Dodanie mo¿liwoœci testowania ca³ych katalogów i wersji.
      
    \\ \hline
    Dawid £azarczyk &
    Zaimplementowanie ca³ej komunikacji z Chunkerem \newline
    Dodanie interfejsów do ChunkUpdate. \newline
    Dodanie algorytmu diff. \newline
    Zaimplementowanie optymalnego algorytmu delta kompresji. \newline
    Generowanie wykresów dla wielu eksperymentów na raz.
    
    \\ \hline
    Marcel Ziêba &
    Przygotowanie œrodowiska - repozytorium, frameworka do testowania, statyczna analiza kodu, code review \newline
    Zaimplementowanie podstawowych klas odpowiadaj¹cych za przechowywanie danych. \newline
		Zaimplementowanie podstawowej wersji GUI. \newline
    Dodanie kompresji LZO i ZIP. \newline
    Dodanie mo¿liwoœci generowania i wyœwietlania wykresów w GUI.
       
    \\ \hline
    \end{tabular}
\end{center}

\chapter{Podsumowanie}
Eksperymenty przeprowadzone w naszym symulatorze pokaza³y, ¿e jest sens analizowania i rozwijania algorytmów delta kodowania.
Wybrany przez nas algorytm korzystaj¹cy z indeksu podobieñstwa daje rezultaty porównywalne z algorytmem optymalnym dla pewnych danych, np. kodów Ÿród³owych.
Zysk wzglêdem algorytmu u¿ywaj¹cego jedynie deduplikacji jest zauwa¿alny zw³aszcza, gdy zosta³y przeprowadzone niewielkie zmiany w wielu plikach.
Jednak dla innych danych mo¿e siê okazaæ, ¿e uzyskana redukcja rozmiaru danych jest na tyle ma³a, ¿e nie op³aca siê obci¹¿aæ systemu intensywnym obliczeniowo algorytmem delta kodowania.
Niebagatelne znaczenie ma czêstoœæ wykonywania kopii zapasowych - im czêœciej siê je wykonuje, tym wiêksza szansa na znalezienie podobnych danych i tym samym wiêkszy zysk z delta kodowania.

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

% wzor: \bibitem[Bea65]{beaman} Juliusz Beaman, \textit{Morbidity of the Jolly function}, Mathematica Absurdica, 117 (1965) 338--9.

\bibitem{work1} P. Shilane, M. Huang, G. Wallace, W. Hsu, \textit{WAN-optimized replication of backup datasets using stream-informed delta compression.} TOS 8(4): 13 (2012)

\bibitem{work2} P. Shilane, M. Huang, G. Wallace, W. Hsu, \textit{Delta Compressed and Deduplicated Storage
Using Stream-Informed Locality}, HotStorage (2012).

\bibitem{work3} T. Suel, N. Memon, \textit{Algorithms for Delta Compression and Remote File
Synchronization}, CIS Department
Polytechnic University
Brooklyn, NY 11201 (2002).

\bibitem{wxPython} Dokumentacja wxPython, \url{http://wxpython.org/Phoenix/docs/html/main.html} [21.01.2015r.]

\bibitem{xDelta} Biblioteka do liczenia diffów \textit{xdelta}, \url{http://xdelta.org/} [21.01.2015r.]

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
